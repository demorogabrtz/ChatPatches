import groovy.json.JsonSlurper

import java.util.function.BiFunction
import java.util.function.Function
import java.util.stream.Stream

plugins {
	id "fabric-loom" version "1.7-SNAPSHOT"
	id "maven-publish"
	id "me.modmuss50.mod-publish-plugin" version "0.7.4"
}

group = project.group
version = project.version

base {
	archivesName = project.archives_base_name
}

// global publishing variables - shouldPublish defaults to true, but can be set to false by using `-PshouldPublish=false`
def shouldPublish = Boolean.parseBoolean( providers.gradleProperty("shouldPublish").getOrElse("true") )
def changelogText = "Changelog could not be found... ðŸ˜¬"

repositories {
  	mavenCentral()

	maven { url "https://maven.terraformersmc.com/releases/" } // Mod Menu
	maven { url "https://maven.isxander.dev/releases" } // YACL
}

dependencies {
	minecraft "com.mojang:minecraft:$project.minecraft"
	mappings "net.fabricmc:yarn:$project.minecraft$project.yarn:v2"
	modImplementation "net.fabricmc:fabric-loader:$project.loader"
	modImplementation "net.fabricmc.fabric-api:fabric-api:$project.api"

	modImplementation "com.terraformersmc:modmenu:$project.modmenu"
	modImplementation "dev.isxander:yet-another-config-lib:$project.yacl-fabric"
}

processResources {
	inputs.property "version", version

	filesMatching("fabric.mod.json") {
		expand "version": version

		/* filter {
			it.replace("example_key", rootProject.exampleVar)
		} */
	}

	def changelog = file("changelog.md")
	if( changelog.exists() ) {
		// replaces github issue numbers with links
		file("changelog.md").text = changelog.text.replaceAll("##(\\d+)", "[#\$1](https://www.github.com/mrbuilder1961/ChatPatches/issues/\$1)")

		// hackily gets the first changelog entry
		def newEntryTitle = "## Chat Patches `" + version + "`"
		def prevEntryIndex = file("changelog.md").text.replaceFirst(newEntryTitle, "").indexOf("## Chat Patches `") + newEntryTitle.length() - 2

		changelogText = file("changelog.md").text.substring(0, prevEntryIndex).replaceFirst("# Changelog\\s+", "")

		// considered "malformed" if it doesn't end with any word characters, whitespace, or newlines
		if( !changelogText.matches("(?s).*(\\s+|(\r?\n)+|\\w+)\$") ) {
			print "/!\\ Warning: /!\\ Changelog seemed malformed, this is probably caused by an invalid version ($version)."
			if(shouldPublish) {
				shouldPublish = false
				print " Cancelled publishing, just in case."
			}
			println()
		}
	}

	if(changelogText.length() > 2000) {
		def more = "..\n***.. and more! Check out the full release notes on GitHub!***"
		changelogText = changelogText.substring(0, 2000 - more.length()).stripTrailing() + more

		println "Trimmed changelog, was over 2000 characters"
	}

	if(!shouldPublish)
		println "Using changelog text:\n>$changelogText<"
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 21
}

java {
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

jar {
	from("LICENSE") {
		rename { "${it}_${project.base.archivesName.get()}"}
	}
}

publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {}
}

publishMods {
	// constants
	def v = rootProject.version
	File secrets = file("secrets.json") // tokens revert to '-' when no secrets.json exists OR the token is not found
	Function<String, List<String>> propListGetter = (String propertyName) ->
			rootProject[propertyName] != null ? Stream.of( rootProject[propertyName].toString().split(",") ).filter{!it.isBlank()}.toList() : new ArrayList<>()
	BiFunction<String, Boolean, String> tokenGetter = (String tokenName, boolean valid) ->
			valid && secrets.exists() ? Objects.requireNonNullElse(new JsonSlurper().parse(secrets)[tokenName], "-") : "-"

	// gradle.properties vars
	String phase = rootProject.phase.toString().toLowerCase()
	List<String> loaders = propListGetter.apply("loaders") // Arrays.asList( rootProject.loaders.toString().split(",") )
	List<String> targets = propListGetter.apply("targets") // Arrays.asList( rootProject.targets.toString().split(",") )
	String[] required = propListGetter.apply("required").toArray()
	String[] optionals = propListGetter.apply("optionals").toArray()
	String[] incompatibles = propListGetter.apply("incompatibles").toArray()
	String[] embedded = propListGetter.apply("embedded").toArray()
	String branch = rootProject.branch.toString()
	// tokens - token name and if it should return the token or "-"
	String cfToken = tokenGetter.apply("curseforge", shouldPublish)
	String mrToken = tokenGetter.apply("modrinth", shouldPublish)
	String ghToken = tokenGetter.apply("github", shouldPublish)
	String dcToken = tokenGetter.apply("discord", shouldPublish)
	String dcDebugToken = tokenGetter.apply("discord_debug", !shouldPublish) // always publishes to debug webhook


	displayName = v.toString()
	file = remapJar.archiveFile // Forge would use jar (NeoForge? i think so..)
	changelog = changelogText
	type = (phase.matches("release|stable") ? STABLE : phase.matches("beta") ? BETA : ALPHA)
	modLoaders = loaders
	dryRun = !shouldPublish

	if(shouldPublish) {
		println "Publishing v$v to $loaders on $targets!"
	} else {
		println "Not publishing v$v because shouldPublish was false! Maybe check if the changelog was malformed?"
		println "Using:\n\ttype: $phase\n\tbranch: $branch\n\tloaders: $loaders\n\ttargets: $targets"
		println "\trequired: $required\n\toptionals: $optionals\n\tincompatibles: $incompatibles\n\tembedded: $embedded"
	}

	curseforge {
		accessToken = cfToken
		projectId = rootProject.cfId
		projectSlug = archives_base_name

		minecraftVersions.addAll(targets)
		clientRequired = true

		requires(required)
		optional(optionals)
		incompatible(incompatibles)
		embeds(embedded)
	}

	modrinth {
		accessToken = mrToken
		projectId = rootProject.mrId

		minecraftVersions.addAll(targets)

		// specify id OR slug NOT both, +OPTIONAL specific version
		requires(required)
		optional(optionals)
		incompatible(incompatibles)
		embeds(embedded)
	}

	github {
		accessToken = ghToken
		repository = "mrbuilder1961/ChatPatches"
		commitish = branch // publishes to the latest supported (targeted) version
		tagName = "$branch-$v" // branch-version

		additionalFiles.from(remapSourcesJar.archiveFile, jar.archiveFile)
	}

	discord {
		webhookUrl = dcToken // official
		dryRunWebhookUrl = dcDebugToken // debug testing
		username = "Publisher Bot"
		avatarUrl = "https://cdn.modrinth.com/data/MOqt4Z5n/56c954dea290ef4dd1b0d6ea92a811acac62ca85.png"
	}
}